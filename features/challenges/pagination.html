---
layout: features
permalink: /features/challenges/pagination/
---

<div>
  <h1>Pagination</h1>
  <p>
    Useful for moving through large datasets, and providing the user with a sliced view of the data.
  </p>

  <h3>Visualization</h3>
  <p>
    This video demonstrates what pagination looks like. Screenshots are from the <em>Simply Social</em> prototype
    that <a href="https://www.invisionapp.com/">Invision</a> provides you when you sign up for an account.
  </p>

  <div class="video">
    <div class="embed-responsive embed-responsive-16by9 drop-shadow pretty-embed" data-pe-videoid="JpztALTbySU" data-pe-fitvids="true">
    </div>
  </div>

  <h3>Architecture Challenge</h3>
  <p>
    The core challenge here, similar to filtering, is preventing action/reducer explosion, but also being able to work
    <em>along side</em> filtering. Both of these involve slicing data up into pieces and you need both of them to work
    together and side-by-side.
  </p>

  <h3>Architecture Implementation</h3>
  <p>This video describes how Lore implements pagination.</p>

  <blockquote>
    <p>
      NOTE: Seeing as pagination is no longer a proposal (and is now part of the framework) this video is currently
      outdated. The approach it illustrates however does closely describe how Lore implements pagination.
    </p>
    <p>
      In the future this video will be updated to fully reflect the final implementation.
    </p>
  </blockquote>

  <div class="video">
    <div class="embed-responsive embed-responsive-16by9 drop-shadow pretty-embed" data-pe-videoid="4lsKM1WvdL4">
    </div>
  </div>

  <h3>Usage</h3>
  <p>
    For a demonstration of pagination in action, please see the <a href="https://github.com/lore/lore/tree/master/examples/pagination">pagination example</a>.
  </p>
  <p>
    Pagination is very similar to filtering, except that you include a second property in the <code>getState</code> call
    named <code>pagination</code>. The properties passed to <code>where</code> and <code>pagination</code> are then
    combined to form the query parameters for the final URL for the API call. For the example code below, the final
    URL might look like this:
  </p>

  <figure class="highlight">
    <pre><code>https://api.myapp.com/posts?authorId=123&page=2</code></pre>
  </figure>

  <p>
    When implementing pagination, it's recommended to use the route specify which page of data to display, such as:
  </p>

  <figure class="highlight">
    <pre><code>https://www.myapp.com/posts?page=2</code></pre>
  </figure>

  <p>
    This will make it easy to support as everytime the route changes the `connect` call in the components will get a
    change to rebuild their data request for the new page of data (if it's changed). Below is some example code in
    ES5/ES6/ESNext syntax showing a component using this approach to request a page of data.
  </p>

  <ul class="nav nav-tabs" role="tablist">
    <li role="presentation" class="active">
      <a href="#tab-usage-es5" role="tab" data-toggle="tab">
        ES5
      </a>
    </li>
    <li role="presentation" class="">
      <a href="#tab-usage-es6" role="tab" data-toggle="tab">
        ES6
      </a>
    </li>
    <li role="presentation" class="">
      <a href="#tab-usage-esnext" role="tab" data-toggle="tab">
        ESNext
      </a>
    </li>
  </ul>

  <div class="tab-content">
    <div role="tabpanel" class="tab-pane active" id="tab-usage-es5">
      {% include features/usage/pagination/es5.html %}
    </div>
    <div role="tabpanel" class="tab-pane" id="tab-usage-es6">
      {% include features/usage/pagination/es6.html %}
    </div>
    <div role="tabpanel" class="tab-pane" id="tab-usage-esnext">
      {% include features/usage/pagination/es7.html %}
    </div>
  </div>

</div>
